#!/usr/bin/env bash
# biglab.sh — Large Oracle (seeded) + empty Postgres for migration testing
# Requires: Docker + docker compose plugin (v2), bash
set -euo pipefail

# # Usage:
# bash biglab.sh up              # start both DBs and seed Oracle
# bash biglab.sh logs            # follow container logs
# bash biglab.sh psql            # open psql to Postgres
# bash biglab.sh sqlplus         # open sqlplus to Oracle (as MIGTEST)
# bash biglab.sh reset           # drop and recreate both (fresh seed)
# bash biglab.sh down            # stop (keep volumes)
# bash biglab.sh destroy         # stop + remove volumes

# -------------------------
# Config (override via env)
# -------------------------
ORACLE_IMAGE="${ORACLE_IMAGE:-gvenzl/oracle-xe:21-slim}"
ORACLE_CONTAINER="${ORACLE_CONTAINER:-oracle_xe_big}"
ORACLE_PASSWORD="${ORACLE_PASSWORD:-oracle}"    # SYSTEM/SYS
ORACLE_APP_USER="${ORACLE_APP_USER:-MIGTEST}"
ORACLE_APP_PASS="${ORACLE_APP_PASS:-MIGTEST}"
ORACLE_SERVICE="${ORACLE_SERVICE:-XEPDB1}"
ORACLE_PORT="${ORACLE_PORT:-1521}"

POSTGRES_IMAGE="${POSTGRES_IMAGE:-postgres:16}"
POSTGRES_CONTAINER="${POSTGRES_CONTAINER:-pg16_target}"
POSTGRES_PORT="${POSTGRES_PORT:-5432}"
PGUSER="${PGUSER:-postgres}"
PGPASSWORD="${PGPASSWORD:-postgres}"
PGDATABASE="${PGDATABASE:-migration_target}"

# Scale knobs (huge by default; tune down if XE is slow on your box)
CUSTOMERS_N="${CUSTOMERS_N:-100000}"      # 1e5 customers
ORDERS_N="${ORDERS_N:-1000000}"           # 1e6 orders
ITEMS_PER_ORDER="${ITEMS_PER_ORDER:-3}"   # ~3e6 order_items rows

# ---------------------------------
# Helpers
# ---------------------------------
here() { cd "$(dirname "$0")"; }
say()  { printf "\n\033[1;36m[%s]\033[0m %s\n" "$1" "${2:-}"; }
die()  { echo "Error: $*" >&2; exit 1; }

wait_oracle() {
  say "oracle" "waiting for listener on ${ORACLE_PORT} and DB to be ready…"
  # wait for port
  for i in {1..120}; do
    if (command -v nc >/dev/null && nc -z localhost "${ORACLE_PORT}") || (command -v timeout >/dev/null && timeout 1 bash -c "</dev/tcp/localhost/${ORACLE_PORT}" 2>/dev/null); then
      break
    fi
    sleep 1
    [[ $i -eq 120 ]] && die "Oracle port ${ORACLE_PORT} not open"
  done
  # wait for health
  for i in {1..120}; do
    state=$(docker inspect -f '{{.State.Health.Status}}' "${ORACLE_CONTAINER}" 2>/dev/null || echo starting)
    [[ "${state}" == "healthy" ]] && { say "oracle" "healthy"; return 0; }
    sleep 2
  done
  die "Oracle did not become healthy in time"
}

wait_postgres() {
  say "postgres" "waiting for readiness on ${POSTGRES_PORT}…"
  for i in {1..120}; do
    if docker exec "${POSTGRES_CONTAINER}" pg_isready -U "${PGUSER}" -d "${PGDATABASE}" >/dev/null 2>&1; then
      say "postgres" "ready"
      return 0
    fi
    sleep 1
  done
  die "Postgres not ready"
}

start_oracle() {
  say "oracle" "starting container ${ORACLE_CONTAINER}"
  docker rm -f "${ORACLE_CONTAINER}" >/dev/null 2>&1 || true
  docker run -d --name "${ORACLE_CONTAINER}" \
    -p "${ORACLE_PORT}:1521" \
    -e ORACLE_PASSWORD="${ORACLE_PASSWORD}" \
    -e APP_USER="${ORACLE_APP_USER}" \
    -e APP_USER_PASSWORD="${ORACLE_APP_PASS}" \
    -e ORACLE_CHARACTERSET="AL32UTF8" \
    --health-cmd="bash -lc \"echo 'select 1 from dual;' | sqlplus -s system/${ORACLE_PASSWORD}@//localhost:${ORACLE_PORT}/${ORACLE_SERVICE}\"" \
    --health-interval=15s --health-timeout=5s --health-retries=60 \
    "${ORACLE_IMAGE}" >/dev/null
  wait_oracle
}

seed_oracle() {
  say "oracle" "seeding large dataset (this can take a while)"
  local tmp_sql
  tmp_sql="$(mktemp)"
  cat > "${tmp_sql}" <<SQL
-- Large seed for ${ORACLE_APP_USER} on ${ORACLE_SERVICE}
WHENEVER SQLERROR EXIT 1
ALTER SESSION SET CURRENT_SCHEMA = ${ORACLE_APP_USER};

-- Customers
BEGIN
  EXECUTE IMMEDIATE 'CREATE TABLE customers (
    customer_id   NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name          VARCHAR2(100),
    email         VARCHAR2(255) UNIQUE,
    status        VARCHAR2(20) CHECK (status IN (''ACTIVE'',''INACTIVE'')),
    created_at    TIMESTAMP(6) DEFAULT SYSTIMESTAMP
  )';
EXCEPTION WHEN OTHERS THEN IF SQLCODE != -955 THEN RAISE; END IF; END;
/

INSERT /*+ APPEND */ INTO customers (name, email, status, created_at)
SELECT
  'Customer '||lvl,
  LOWER('user'||lvl||'@example.com'),
  CASE WHEN MOD(lvl,10)=0 THEN 'INACTIVE' ELSE 'ACTIVE' END,
  SYSTIMESTAMP - NUMTODSINTERVAL(MOD(lvl, 864000), 'SECOND')
FROM (SELECT LEVEL AS lvl FROM dual CONNECT BY LEVEL <= ${CUSTOMERS_N});
COMMIT;

-- Orders
BEGIN
  EXECUTE IMMEDIATE 'CREATE TABLE orders (
    order_id     NUMBER PRIMARY KEY,
    customer_id  NUMBER NOT NULL,
    order_total  NUMBER(12,2),
    note         CLOB,
    placed_at    DATE DEFAULT SYSDATE,
    CONSTRAINT fk_orders_customer FOREIGN KEY (customer_id) REFERENCES customers(customer_id)
  )';
EXCEPTION WHEN OTHERS THEN IF SQLCODE != -955 THEN RAISE; END IF; END;
/

CREATE SEQUENCE orders_seq START WITH 1 NOCACHE;

INSERT /*+ APPEND */ INTO orders (order_id, customer_id, order_total, note, placed_at)
SELECT
  orders_seq.NEXTVAL,
  MOD(lvl, ${CUSTOMERS_N}) + 1,
  ROUND(DBMS_RANDOM.VALUE(10, 5000), 2),
  TO_CLOB('order '||lvl),
  SYSDATE - MOD(lvl, 365)
FROM (SELECT LEVEL AS lvl FROM dual CONNECT BY LEVEL <= ${ORDERS_N});
COMMIT;

-- Order items (~ ORDERS_N * ITEMS_PER_ORDER rows)
BEGIN
  EXECUTE IMMEDIATE 'CREATE TABLE order_items (
    order_id   NUMBER NOT NULL,
    line_no    NUMBER NOT NULL,
    sku        VARCHAR2(20),
    qty        NUMBER,
    price      NUMBER(10,2),
    CONSTRAINT pk_order_items PRIMARY KEY (order_id, line_no),
    CONSTRAINT fk_items_order FOREIGN KEY (order_id) REFERENCES orders(order_id)
  )';
EXCEPTION WHEN OTHERS THEN IF SQLCODE != -955 THEN RAISE; END IF; END;
/

-- Generate line numbers 1..ITEMS_PER_ORDER
WITH lines AS (
  SELECT LEVEL AS ln FROM dual CONNECT BY LEVEL <= ${ITEMS_PER_ORDER}
)
INSERT /*+ APPEND */ INTO order_items (order_id, line_no, sku, qty, price)
SELECT
  o.order_id,
  l.ln,
  'SKU'||TO_CHAR(MOD(o.order_id*31 + l.ln, 999999), 'FM000000'),
  MOD(o.order_id + l.ln, 10) + 1,
  ROUND(DBMS_RANDOM.VALUE(5, 200), 2)
FROM orders o
CROSS JOIN lines l;
COMMIT;

-- Text docs (CLOB)
BEGIN
  EXECUTE IMMEDIATE 'CREATE TABLE docs (
    doc_id    NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    customer_id NUMBER NOT NULL,
    body      CLOB,
    created_at TIMESTAMP(6) DEFAULT SYSTIMESTAMP
  )';
EXCEPTION WHEN OTHERS THEN IF SQLCODE != -955 THEN RAISE; END IF; END;
/

INSERT /*+ APPEND */ INTO docs (customer_id, body)
SELECT
  MOD(level, ${CUSTOMERS_N}) + 1,
  RPAD(TO_CLOB('lorem ipsum '||level||' '), 4000, '*')
FROM dual CONNECT BY level <= (LEAST(${CUSTOMERS_N}, 100000));
COMMIT;

-- Function-based index example
BEGIN
  EXECUTE IMMEDIATE 'CREATE INDEX idx_customers_email_lower ON customers (LOWER(email))';
EXCEPTION WHEN OTHERS THEN IF SQLCODE != -955 THEN RAISE; END IF; END;
/

-- Basic stats for realistic plans
BEGIN
  DBMS_STATS.GATHER_SCHEMA_STATS(ownname => '${ORACLE_APP_USER}', estimate_percent => 5, cascade => TRUE, no_invalidate => FALSE);
END;
/
SQL

  docker cp "${tmp_sql}" "${ORACLE_CONTAINER}:/tmp/seed.sql"
  rm -f "${tmp_sql}"
  docker exec -i "${ORACLE_CONTAINER}" bash -lc "sqlplus -s system/${ORACLE_PASSWORD}@//localhost:${ORACLE_PORT}/${ORACLE_SERVICE} @/tmp/seed.sql"
  say "oracle" "seeding complete"
}

start_postgres() {
  say "postgres" "starting container ${POSTGRES_CONTAINER}"
  docker rm -f "${POSTGRES_CONTAINER}" >/dev/null 2>&1 || true
  docker run -d --name "${POSTGRES_CONTAINER}" \
    -p "${POSTGRES_PORT}:5432" \
    -e POSTGRES_USER="${PGUSER}" \
    -e POSTGRES_PASSWORD="${PGPASSWORD}" \
    -e POSTGRES_DB="${PGDATABASE}" \
    --health-cmd="pg_isready -U ${PGUSER} -d ${PGDATABASE}" \
    --health-interval=10s --health-timeout=5s --health-retries=60 \
    "${POSTGRES_IMAGE}" >/dev/null
  wait_postgres
}

psql_shell() {
  docker exec -it "${POSTGRES_CONTAINER}" psql -U "${PGUSER}" -d "${PGDATABASE}"
}

sqlplus_shell() {
  docker exec -it "${ORACLE_CONTAINER}" sqlplus ${ORACLE_APP_USER}/${ORACLE_APP_PASS}@${ORACLE_SERVICE}
}

compose_up() {
  start_oracle
  start_postgres
  seed_oracle
  say "done" "Oracle (seeded) + Postgres (empty) are up."
  echo
  echo "Oracle connect (app user): sqlplus ${ORACLE_APP_USER}/${ORACLE_APP_PASS}@//localhost:${ORACLE_PORT}/${ORACLE_SERVICE}"
  echo "Postgres connect: psql -h localhost -p ${POSTGRES_PORT} -U ${PGUSER} -d ${PGDATABASE}"
}

case "${1:-up}" in
  up)        here; compose_up ;;
  reset)     here; bash "$0" destroy; bash "$0" up ;;
  logs)      docker logs -f "${ORACLE_CONTAINER}" & docker logs -f "${POSTGRES_CONTAINER}" ;;
  psql)      psql_shell ;;
  sqlplus)   sqlplus_shell ;;
  down)      docker rm -f "${ORACLE_CONTAINER}" >/dev/null 2>&1 || true; docker rm -f "${POSTGRES_CONTAINER}" >/dev/null 2>&1 || true ;;
  destroy)   bash "$0" down; say "nuke" "removing volumes (if any)"; docker volume prune -f >/dev/null || true ;;
  *)         echo "Usage: $0 [up|reset|down|destroy|logs|psql|sqlplus]"; exit 1 ;;
esac
